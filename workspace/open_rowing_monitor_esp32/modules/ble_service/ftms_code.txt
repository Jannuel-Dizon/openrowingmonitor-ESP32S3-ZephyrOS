ble/ftms/DeviceInformationService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  todo: Could provide some info on the device here, maybe OS, Node version etc...
*/
import bleno from '@abandonware/bleno'

export default class DeviceInformationService extends bleno.PrimaryService {
  constructor (controlPointCallback) {
    super({
      // uuid of "Device Information Service"
      uuid: '180a',
      characteristics: [
      ]
    })
  }
}

ble/ftms/FitnessMachineControlPointCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  The connected Central can remotly control some parameters or our rowing monitor via this Control Point

  So far tested on:
    - Fulgaz: uses setIndoorBikeSimulationParameters
    - Zwift: uses startOrResume and setIndoorBikeSimulationParameters
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'

// see https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0 for details
const ControlPointOpCode = {
  requestControl: 0x00,
  reset: 0x01,
  setTargetSpeed: 0x02,
  setTargetInclincation: 0x03,
  setTargetResistanceLevel: 0x04,
  setTargetPower: 0x05,
  setTargetHeartRate: 0x06,
  startOrResume: 0x07,
  stopOrPause: 0x08,
  setTargetedExpendedEnergy: 0x09,
  setTargetedNumberOfSteps: 0x0A,
  setTargetedNumberOfStrides: 0x0B,
  setTargetedDistance: 0x0C,
  setTargetedTrainingTime: 0x0D,
  setTargetedTimeInTwoHeartRateZones: 0x0E,
  setTargetedTimeInThreeHeartRateZones: 0x0F,
  setTargetedTimeInFiveHeartRateZones: 0x10,
  setIndoorBikeSimulationParameters: 0x11,
  setWheelCircumference: 0x12,
  spinDownControl: 0x13,
  setTargetedCadence: 0x14,
  responseCode: 0x80
}

const ResultCode = {
  reserved: 0x00,
  success: 0x01,
  opCodeNotSupported: 0x02,
  invalidParameter: 0x03,
  operationFailed: 0x04,
  controlNotPermitted: 0x05
}

export default class FitnessMachineControlPointCharacteristic extends bleno.Characteristic {
  constructor (controlPointCallback) {
    super({
      // Fitness Machine Control Point
      uuid: '2AD9',
      value: null,
      properties: ['write']
    })

    this.controlled = false
    if (!controlPointCallback) { throw new Error('controlPointCallback required') }
    this.controlPointCallback = controlPointCallback
  }

  // Central sends a command to the Control Point
  // todo: handle offset and withoutResponse properly
  onWriteRequest (data, offset, withoutResponse, callback) {
    const opCode = data.readUInt8(0)
    switch (opCode) {
      case ControlPointOpCode.requestControl:
        if (!this.controlled) {
          if (this.controlPointCallback({ name: 'requestControl' })) {
            log.debug('requestControl sucessful')
            this.controlled = true
            callback(this.buildResponse(opCode, ResultCode.success))
          } else {
            callback(this.buildResponse(opCode, ResultCode.operationFailed))
          }
        } else {
          callback(this.buildResponse(opCode, ResultCode.controlNotPermitted))
        }
        break

      case ControlPointOpCode.reset:
        this.handleSimpleCommand(ControlPointOpCode.reset, 'reset', callback)
        // as per spec the reset command shall also reset the control
        this.controlled = false
        break

      case ControlPointOpCode.startOrResume:
        this.handleSimpleCommand(ControlPointOpCode.startOrResume, 'startOrResume', callback)
        break

      case ControlPointOpCode.stopOrPause: {
        const controlParameter = data.readUInt8(1)
        if (controlParameter === 1) {
          this.handleSimpleCommand(ControlPointOpCode.stopOrPause, 'stop', callback)
        } else if (controlParameter === 2) {
          this.handleSimpleCommand(ControlPointOpCode.stopOrPause, 'pause', callback)
        } else {
          log.error(`stopOrPause with invalid controlParameter: ${controlParameter}`)
        }
        break
      }

      // todo: Most tested bike apps use these to simulate a bike ride. Not sure how we can use these in our rower
      // since there is no adjustable resistance on the rowing machine
      case ControlPointOpCode.setIndoorBikeSimulationParameters: {
        const windspeed = data.readInt16LE(1) * 0.001
        const grade = data.readInt16LE(3) * 0.01
        const crr = data.readUInt8(5) * 0.0001
        const cw = data.readUInt8(6) * 0.01
        if (this.controlPointCallback({ name: 'setIndoorBikeSimulationParameters', value: { windspeed, grade, crr, cw } })) {
          callback(this.buildResponse(opCode, ResultCode.success))
        } else {
          callback(this.buildResponse(opCode, ResultCode.operationFailed))
        }
        break
      }

      default:
        log.info(`opCode ${opCode} is not supported`)
        callback(this.buildResponse(opCode, ResultCode.opCodeNotSupported))
    }
  }

  handleSimpleCommand (opCode, opName, callback) {
    if (this.controlled) {
      if (this.controlPointCallback({ name: opName })) {
        const response = this.buildResponse(opCode, ResultCode.success)
        callback(response)
      } else {
        callback(this.buildResponse(opCode, ResultCode.operationFailed))
      }
    } else {
      log.info(`initating command '${opName}' requires 'requestControl'`)
      callback(this.buildResponse(opCode, ResultCode.controlNotPermitted))
    }
  }

  // build the response message as defined by the spec
  buildResponse (opCode, resultCode) {
    const buffer = Buffer.alloc(3)
    buffer.writeUInt8(0x80, 0)
    buffer.writeUInt8(opCode, 1)
    buffer.writeUInt8(resultCode, 2)
    return buffer
  }
}

ble/ftms/FitnessMachineService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implements the Fitness Machine Service (FTMS) according to specs.
  Either presents a FTMS Rower (for rower applications that can use parameters such as Stroke Rate) or
  simulates a FTMS Indoor Bike (for usage with bike training apps)

  Relevant parts from https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0
  For Discovery we should implement:
  - Fitness Machine Feature Characteristic
  - Rower Data Characteristic
  - Training Status Characteristic (not yet implemented) todo: Maybe implement a simple version of it to see which
    applications make use of it. Might become interesting, if we implement training management
  - Fitness Machine Status Characteristic
  - Fitness Machine Control Point Characteristic
*/
import bleno from '@abandonware/bleno'

import RowerDataCharacteristic from './RowerDataCharacteristic.js'
import RowerFeatureCharacteristic from './RowerFeatureCharacteristic.js'
import IndoorBikeDataCharacteristic from './IndoorBikeDataCharacteristic.js'
import IndoorBikeFeatureCharacteristic from './IndoorBikeFeatureCharacteristic.js'
import FitnessMachineControlPointCharacteristic from './FitnessMachineControlPointCharacteristic.js'
import FitnessMachineStatusCharacteristic from './FitnessMachineStatusCharacteristic.js'

export default class FitnessMachineService extends bleno.PrimaryService {
  constructor (options, controlPointCallback) {
    const simulateIndoorBike = options?.simulateIndoorBike === true
    const dataCharacteristic = simulateIndoorBike ? new IndoorBikeDataCharacteristic() : new RowerDataCharacteristic()
    const featureCharacteristic = simulateIndoorBike ? new IndoorBikeFeatureCharacteristic() : new RowerFeatureCharacteristic()
    const statusCharacteristic = new FitnessMachineStatusCharacteristic()
    super({
      // Fitness Machine
      uuid: '1826',
      characteristics: [
        featureCharacteristic,
        dataCharacteristic,
        new FitnessMachineControlPointCharacteristic(controlPointCallback),
        statusCharacteristic
      ]
    })
    this.dataCharacteristic = dataCharacteristic
    this.statusCharacteristic = statusCharacteristic
  }

  notifyData (event) {
    this.dataCharacteristic.notify(event)
  }

  notifyStatus (event) {
    this.statusCharacteristic.notify(event)
  }
}

ble/ftms/FitnessMachineStatusCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implements the Status Characteristics, that can be used to notify the central about the current
  training machine settings. Currently only used to notify the central about training resets.

  From the specs:
  If the Server supports the Fitness Machine Control Point, the Fitness Machine Status characteristic
  shall be exposed by the Server. Otherwise, supporting the Fitness Machine Status characteristic is optional.
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'

// see page 67 https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0
const StatusOpCode = {
  reservedForFutureUse: 0x00,
  reset: 0x01,
  stoppedOrPausedByUser: 0x02,
  stoppedBySafetyKey: 0x03,
  startedOrResumedByUser: 0x04,
  targetSpeedChanged: 0x05,
  targetInclineChanged: 0x06,
  targetResistanceLevelChanged: 0x07,
  targetPowerChanged: 0x08,
  targetHeartRateChanged: 0x09,
  targetExpendedEnergyChanged: 0x0a,
  targetNumberOfStepsChanged: 0x0b,
  targetNumberOfStridesChanged: 0x0c,
  targetDistanceChanged: 0x0d,
  targetTrainingTimeChanged: 0x0e,
  targetedTimeInTwoHeartRateZonesChanged: 0x0f,
  targetedTimeInThreeHeartRateZonesChanged: 0x10,
  targetedTimeInFiveHeartRateZonesChanged: 0x11,
  indoorBikeSimulationParametersChanged: 0x12,
  wheelCircumferenceChanged: 0x13,
  spinDownStatus: 0x14,
  targetedCadenceChanged: 0x15
}

export default class FitnessMachineStatusCharacteristic extends bleno.Characteristic {
  constructor () {
    super({
      // Fitness Machine Status
      uuid: '2ADA',
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`FitnessMachineStatusCharacteristic - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('FitnessMachineStatusCharacteristic - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (status) {
    if (!(status && status.name)) {
      log.error('can not deliver status without name')
      return this.RESULT_SUCCESS
    }
    if (this._updateValueCallback) {
      const buffer = Buffer.alloc(2)
      switch (status.name) {
        case 'reset':
          buffer.writeUInt8(StatusOpCode.reset, 0)
          break
        case 'stoppedOrPausedByUser':
          buffer.writeUInt8(StatusOpCode.stoppedOrPausedByUser, 0)
          break
        case 'startedOrResumedByUser':
          buffer.writeUInt8(StatusOpCode.startedOrResumedByUser, 0)
          break
        default:
          log.error(`status ${status.name} is not supported`)
      }
      this._updateValueCallback(buffer)
    }
    return this.RESULT_SUCCESS
  }
}

ble/ftms/IndoorBikeDataCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This implements the Indoor Bike Data Characteristic as defined by the Bluetooth SIG
  Currently hardly any applications exist that support these FTMS Characteristic for Rowing.
  So we use this to simulate an FTMS Indoor Bike characteristic.
  Of course we can not deliver rowing specific parameters like this (such as stroke rate), but
  this allows us to use the open rowing monitor with bike training platforms such as
  Zwift, Sufferfest, RGT Cycling, Kinomap, Bkool, Rouvy and more...
  So far tested on:
    - Kinomap.com: uses Power and Speed
    - Fulgaz: uses Power and Speed
    - Zwift: uses Power
    - RGT Cycling: connects Power but then disconnects again (seems something is missing here)

  From specs:
  The Server should notify this characteristic at a regular interval, typically once per second
  while in a connection and the interval is not configurable by the Client
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'
import BufferBuilder from '../BufferBuilder.js'

export default class IndoorBikeDataCharacteristic extends bleno.Characteristic {
  constructor () {
    super({
      // Indoor Bike Data
      uuid: '2AD2',
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._subscriberMaxValueSize = null
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`IndoorBikeDataCharacteristic - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    this._subscriberMaxValueSize = maxValueSize
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('IndoorBikeDataCharacteristic - central unsubscribed')
    this._updateValueCallback = null
    this._subscriberMaxValueSize = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    // ignore events without the mandatory fields
    if (!('speed' in data)) {
      log.error('can not deliver bike data without mandatory fields')
      return this.RESULT_SUCCESS
    }

    if (this._updateValueCallback) {
      const bufferBuilder = new BufferBuilder()
      // Field flags as defined in the Bluetooth Documentation
      // Instantaneous speed (default), Instantaneous Cadence (2), Total Distance (4),
      // Instantaneous Power (6), Total / Expended Energy (8), Heart Rate (9), Elapsed Time (11)
      // 01010100
      bufferBuilder.writeUInt8(0x54)
      // 00001011
      bufferBuilder.writeUInt8(0x0B)

      // see https://www.bluetooth.com/specifications/specs/gatt-specification-supplement-3/
      // for some of the data types
      // Instantaneous Speed in km/h
      bufferBuilder.writeUInt16LE(Math.round(data.speed * 100))
      // Instantaneous Cadence in rotations per minute (we use this to communicate the strokes per minute)
      bufferBuilder.writeUInt16LE(Math.round(data.strokesPerMinute * 2))
      // Total Distance in meters
      bufferBuilder.writeUInt24LE(Math.round(data.distanceTotal))
      // Instantaneous Power in watts
      bufferBuilder.writeUInt16LE(Math.round(data.power))
      // Energy
      // Total energy in kcal
      bufferBuilder.writeUInt16LE(Math.round(data.caloriesTotal))
      // Energy per hour
      // The Energy per Hour field represents the average expended energy of a user during a
      // period of one hour.
      bufferBuilder.writeUInt16LE(Math.round(data.caloriesPerHour))
      // Energy per minute
      bufferBuilder.writeUInt8(Math.round(data.caloriesPerMinute))
      // Heart Rate: Beats per minute with a resolution of 1
      bufferBuilder.writeUInt8(Math.round(data.heartrate))
      // Elapsed Time: Seconds with a resolution of 1
      bufferBuilder.writeUInt16LE(Math.round(data.durationTotal))

      const buffer = bufferBuilder.getBuffer()
      if (buffer.length > this._subscriberMaxValueSize) {
        log.warn(`IndoorBikeDataCharacteristic - notification of ${buffer.length} bytes is too large for the subscriber`)
      }
      this._updateValueCallback(bufferBuilder.getBuffer())
    }
    return this.RESULT_SUCCESS
  }
}

ble/ftms/IndoorBikeFeatureCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This implements the Indoor Bike Feature Characteristic as defined by the specification.
  Used to inform the Central about the features that the Open Rowing Monitor supports.
  Make sure that The Fitness Machine Features and Target Setting Features that are announced here
  are supported in IndoorBikeDataCharacteristic and FitnessMachineControlPointCharacteristic.
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'

export default class IndoorBikeDataCharacteristic extends bleno.Characteristic {
  constructor (uuid, description, value) {
    super({
      // Fitness Machine Feature
      uuid: '2ACC',
      properties: ['read'],
      value: null
    })
  }

  onReadRequest (offset, callback) {
    // see https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0 for details
    // Fitness Machine Features for the IndoorBikeDataCharacteristic
    // Cadence Supported (1), Total Distance Supported (2), Expended Energy Supported (9),
    // Heart Rate Measurement Supported (10), Elapsed Time Supported (12), Power Measurement Supported (14)
    // 00000110 01010110
    // Target Setting Features for the IndoorBikeDataCharacteristic
    // none
    // 0000000 0000000
    const features = [0x06, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    log.debug('Features of Indoor Bike requested')
    callback(this.RESULT_SUCCESS, features.slice(offset, features.length))
  }
}

ble/ftms/RowerDataCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This implements the Rower Data Characteristic as defined by the Bluetooth SIG
  Currently not many applications exist that support thes FTMS Characteristic for Rowing so its hard
  to verify this. So far tested on:
    - Kinomap.com: uses Power, Split Time and Strokes per Minutes

  From the specs:
  The Server should notify this characteristic at a regular interval, typically once per second
  while in a connection and the interval is not configurable by the Client
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'
import BufferBuilder from '../BufferBuilder.js'

export default class RowerDataCharacteristic extends bleno.Characteristic {
  constructor () {
    super({
      // Rower Data
      uuid: '2AD1',
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._subscriberMaxValueSize = null
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`RowerDataCharacteristic - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    this._subscriberMaxValueSize = maxValueSize
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('RowerDataCharacteristic - central unsubscribed')
    this._updateValueCallback = null
    this._subscriberMaxValueSize = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    // ignore events without the mandatory fields
    if (!('strokesPerMinute' in data && 'strokesTotal' in data)) {
      return this.RESULT_SUCCESS
    }

    if (this._updateValueCallback) {
      const bufferBuilder = new BufferBuilder()
      // Field flags as defined in the Bluetooth Documentation
      // Stroke Rate (default), Stroke Count (default), Total Distance (2), Instantaneous Pace (3),
      // Instantaneous Power (5), Total / Expended Energy (8), Heart Rate (9), Elapsed Time (11)
      // todo: might add: Average Stroke Rate (1), Average Pace (4), Average Power (6)
      // Remaining Time (12)
      // 00101100
      bufferBuilder.writeUInt8(0x2c)
      // 00001011
      bufferBuilder.writeUInt8(0x0B)

      // see https://www.bluetooth.com/specifications/specs/gatt-specification-supplement-3/
      // for some of the data types
      // Stroke Rate in stroke/minute, value is multiplied by 2 to have a .5 precision
      bufferBuilder.writeUInt8(Math.round(data.strokesPerMinute * 2))
      // Stroke Count
      bufferBuilder.writeUInt16LE(Math.round(data.strokesTotal))
      // Total Distance in meters
      bufferBuilder.writeUInt24LE(Math.round(data.distanceTotal))
      // Instantaneous Pace in seconds/500m
      // if split is infinite (i.e. while pausing), should use the highest possible number (0xFFFF)
      // todo: eventhough mathematically correct, setting 0xFFFF (65535s) causes some ugly spikes
      // in some applications which could shift the axis (i.e. workout diagrams in MyHomeFit)
      // so instead for now we use 0 here
      bufferBuilder.writeUInt16LE(data.split !== Infinity ? Math.round(data.split) : 0)
      // Instantaneous Power in watts
      bufferBuilder.writeUInt16LE(Math.round(data.power))
      // Energy in kcal
      // Total energy in kcal
      bufferBuilder.writeUInt16LE(Math.round(data.caloriesTotal))
      // Energy per hour
      // The Energy per Hour field represents the average expended energy of a user during a
      // period of one hour.
      bufferBuilder.writeUInt16LE(Math.round(data.caloriesPerHour))
      // Energy per minute
      bufferBuilder.writeUInt8(Math.round(data.caloriesPerMinute))
      // Heart Rate: Beats per minute with a resolution of 1
      bufferBuilder.writeUInt8(Math.round(data.heartrate))
      // Elapsed Time: Seconds with a resolution of 1
      bufferBuilder.writeUInt16LE(Math.round(data.durationTotal))

      const buffer = bufferBuilder.getBuffer()
      if (buffer.length > this._subscriberMaxValueSize) {
        log.warn(`RowerDataCharacteristic - notification of ${buffer.length} bytes is too large for the subscriber`)
      }
      this._updateValueCallback(bufferBuilder.getBuffer())
    }
    return this.RESULT_SUCCESS
  }
}

ble/ftms/RowerFeatureCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This implements the Rower Feature Characteristic as defined by the specification.
  Used to inform the Central about the features that the Open Rowing Monitor supports.
  Make sure that The Fitness Machine Features and Target Setting Features that are announced here
  are supported in RowerDataCharacteristic and FitnessMachineControlPointCharacteristic.
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'

export default class RowerFeatureCharacteristic extends bleno.Characteristic {
  constructor () {
    super({
      // Fitness Machine Feature
      uuid: '2ACC',
      properties: ['read'],
      value: null
    })
  }

  onReadRequest (offset, callback) {
    // see https://www.bluetooth.com/specifications/specs/fitness-machine-service-1-0 for details
    // Fitness Machine Features for the RowerDataCharacteristic
    // Total Distance Supported (2), Pace Supported (5), Expended Energy Supported (9),
    // Heart Rate Measurement Supported (10), Elapsed Time Supported (bit 12),
    // Power Measurement Supported (14)
    // 00100100 01010110
    // Target Setting Features for the RowerDataCharacteristic
    // none
    // 0000000 0000000
    const features = [0x24, 0x56, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00]
    log.debug('Features of Rower requested')
    callback(this.RESULT_SUCCESS, features.slice(offset, features.length))
  };
}

ble/pm5/characteristic/AdditionalStatus.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the AdditionalStatus as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class AdditionalStatus extends bleno.Characteristic {
  constructor (multiplexedCharacteristic) {
    super({
      // id for AdditionalStatus as defined in the spec
      uuid: getFullUUID('0032'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._multiplexedCharacteristic = multiplexedCharacteristic
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`AdditionalStatus - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('AdditionalStatus - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback || this._multiplexedCharacteristic.centralSubscribed()) {
      const bufferBuilder = new BufferBuilder()
      // elapsedTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(Math.round(data.durationTotal * 100))
      // speed: UInt16LE in 0.001 m/sec
      bufferBuilder.writeUInt16LE(Math.round(data.speed * 1000 / 3.6))
      // strokeRate: UInt8 in strokes/min
      bufferBuilder.writeUInt8(Math.round(data.strokesPerMinute))
      // heartrate: UInt8 in bpm, 255 if invalid
      bufferBuilder.writeUInt8(Math.round(data.heartrate))
      // currentPace: UInt16LE in 0.01 sec/500m
      // if split is infinite (i.e. while pausing), use the highest possible number
      bufferBuilder.writeUInt16LE(data.split !== Infinity ? Math.round(data.split * 100) : 0xFFFF)
      // averagePace: UInt16LE in 0.01 sec/500m
      let averagePace = 0
      if (data.distanceTotal && data.distanceTotal !== 0) {
        averagePace = data.durationTotal / data.distanceTotal * 500
      }
      bufferBuilder.writeUInt16LE(Math.round(averagePace * 100))
      // restDistance: UInt16LE
      bufferBuilder.writeUInt16LE(0)
      // restTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(0 * 100)
      if (!this._updateValueCallback) {
      // the multiplexer uses a slightly different format for the AdditionalStatus
      // it adds averagePower before the ergMachineType
      // averagePower: UInt16LE in watts
        bufferBuilder.writeUInt16LE(Math.round(data.power))
      }
      // ergMachineType: 0 TYPE_STATIC_D
      bufferBuilder.writeUInt8(0)

      if (this._updateValueCallback) {
        this._updateValueCallback(bufferBuilder.getBuffer())
      } else {
        this._multiplexedCharacteristic.notify(0x32, bufferBuilder.getBuffer())
      }
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/AdditionalStatus2.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the AdditionalStatus2 as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class AdditionalStatus2 extends bleno.Characteristic {
  constructor (multiplexedCharacteristic) {
    super({
      // id for AdditionalStatus2 as defined in the spec
      uuid: getFullUUID('0033'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._multiplexedCharacteristic = multiplexedCharacteristic
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`AdditionalStatus2 - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('AdditionalStatus2 - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback || this._multiplexedCharacteristic.centralSubscribed()) {
      const bufferBuilder = new BufferBuilder()
      // elapsedTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(Math.round(data.durationTotal * 100))
      // intervalCount: UInt8
      bufferBuilder.writeUInt8(0)
      if (this._updateValueCallback) {
        // the multiplexer uses a slightly different format for the AdditionalStatus2
        // it skips averagePower before totalCalories
        // averagePower: UInt16LE in watts
        bufferBuilder.writeUInt16LE(Math.round(data.power))
      }
      // totalCalories: UInt16LE in cal
      bufferBuilder.writeUInt16LE(Math.round(data.caloriesTotal))
      // splitAveragePace: UInt16LE in 0.01 sec/500m
      bufferBuilder.writeUInt16LE(0 * 100)
      // splitAveragePower UInt16LE in watts
      bufferBuilder.writeUInt16LE(0)
      // splitAverageCalories
      bufferBuilder.writeUInt16LE(0)
      // lastSplitTime
      bufferBuilder.writeUInt24LE(0 * 100)
      // lastSplitDistance in 1 m
      bufferBuilder.writeUInt24LE(0)

      if (this._updateValueCallback) {
        this._updateValueCallback(bufferBuilder.getBuffer())
      } else {
        this._multiplexedCharacteristic.notify(0x33, bufferBuilder.getBuffer())
      }
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/AdditionalStrokeData.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the AdditionalStrokeData as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class AdditionalStrokeData extends bleno.Characteristic {
  constructor (multiplexedCharacteristic) {
    super({
      // id for AdditionalStrokeData as defined in the spec
      uuid: getFullUUID('0036'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._multiplexedCharacteristic = multiplexedCharacteristic
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`AdditionalStrokeData - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('AdditionalStrokeData - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback || this._multiplexedCharacteristic.centralSubscribed()) {
      const bufferBuilder = new BufferBuilder()
      // elapsedTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(Math.round(data.durationTotal * 100))
      // strokePower: UInt16LE in watts
      bufferBuilder.writeUInt16LE(Math.round(data.power))
      // strokeCalories: UInt16LE in cal
      bufferBuilder.writeUInt16LE(0)
      // strokeCount: UInt16LE
      bufferBuilder.writeUInt16LE(Math.round(data.strokesTotal))
      // projectedWorkTime: UInt24LE in 1 sec
      bufferBuilder.writeUInt24LE(0)
      // projectedWorkDistance: UInt24LE in 1 m
      bufferBuilder.writeUInt24LE(0)
      if (!this._updateValueCallback) {
        // the multiplexer uses a slightly different format for the AdditionalStrokeData
        // it adds workPerStroke at the end
        // workPerStroke: UInt16LE
        bufferBuilder.writeUInt16LE(0)
      }

      if (this._updateValueCallback) {
        this._updateValueCallback(bufferBuilder.getBuffer())
      } else {
        this._multiplexedCharacteristic.notify(0x36, bufferBuilder.getBuffer())
      }
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/ControlReceive.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the ControlReceive Characteristic as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
  Used to receive controls from the central
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'

export default class ControlReceive extends bleno.Characteristic {
  constructor () {
    super({
      // id for ControlReceive as defined in the spec
      uuid: getFullUUID('0021'),
      value: null,
      properties: ['write']
    })
    this._updateValueCallback = null
  }

  // Central sends a command to the Control Point
  onWriteRequest (data, offset, withoutResponse, callback) {
    log.debug('ControlReceive command: ', data)
  }
}

ble/pm5/characteristic/ControlTransmit.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the ControlTransmit Characteristic as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
  Used to transmit controls to the central
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class ControlTransmit extends bleno.Characteristic {
  constructor () {
    super({
      // id for ControlTransmit as defined in the spec
      uuid: getFullUUID('0022'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`ControlTransmit - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('ControlTransmit - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback) {
      const bufferBuilder = new BufferBuilder()
      this._updateValueCallback(bufferBuilder.getBuffer())
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/GeneralStatus.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the GeneralStatus as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class GeneralStatus extends bleno.Characteristic {
  constructor (multiplexedCharacteristic) {
    super({
      // id for GeneralStatus as defined in the spec
      uuid: getFullUUID('0031'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._multiplexedCharacteristic = multiplexedCharacteristic
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`GeneralStatus - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('GeneralStatus - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback || this._multiplexedCharacteristic.centralSubscribed()) {
      const bufferBuilder = new BufferBuilder()
      // elapsedTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(Math.round(data.durationTotal * 100))
      // distance: UInt24LE in 0.1 m
      bufferBuilder.writeUInt24LE(Math.round(data.distanceTotal * 10))
      // workoutType: UInt8 will always use 0 (WORKOUTTYPE_JUSTROW_NOSPLITS)
      bufferBuilder.writeUInt8(0)
      // intervalType: UInt8 will always use 255 (NONE)
      bufferBuilder.writeUInt8(255)
      // workoutState: UInt8 0 WAITTOBEGIN, 1 WORKOUTROW, 10 WORKOUTEND
      bufferBuilder.writeUInt8(data.sessionState === 'rowing' ? 1 : (data.sessionState === 'waitingForStart' ? 0 : 10))
      // rowingState: UInt8 0 INACTIVE, 1 ACTIVE
      bufferBuilder.writeUInt8(data.sessionState === 'rowing' ? 1 : 0)
      // strokeState: UInt8 2 DRIVING, 4 RECOVERY
      bufferBuilder.writeUInt8(data.strokeState === 'DRIVING' ? 2 : 4)
      // totalWorkDistance: UInt24LE in 1 m
      bufferBuilder.writeUInt24LE(Math.round(data.distanceTotal))
      // workoutDuration: UInt24LE in 0.01 sec (if type TIME)
      bufferBuilder.writeUInt24LE(0 * 100)
      // workoutDurationType: UInt8 0 TIME, 1 CALORIES, 2 DISTANCE, 3 WATTS
      bufferBuilder.writeUInt8(0)
      // dragFactor: UInt8
      bufferBuilder.writeUInt8(0)

      if (this._updateValueCallback) {
        this._updateValueCallback(bufferBuilder.getBuffer())
      } else {
        this._multiplexedCharacteristic.notify(0x31, bufferBuilder.getBuffer())
      }
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/MultiplexedCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implements the Multiplexed Characteristic as defined by the spec:

  "On some Android platforms, there is a limitation to the number of notification messages allowed.
  To circumvent this issue, a single characteristic (C2 multiplexed data
  info) exists to allow multiple characteristics to be multiplexed onto a single characteristic. The last byte in the
  characteristic will indicate which data characteristic is multiplexed."
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'

export default class MultiplexedCharacteristic extends bleno.Characteristic {
  constructor () {
    super({
      // id for MultiplexedInformation as defined in the spec
      uuid: getFullUUID('0080'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`MultiplexedCharacteristic - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('MultiplexedCharacteristic - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  centralSubscribed () {
    return this._updateValueCallback !== null
  }

  notify (id, characteristicBuffer) {
    const characteristicId = Buffer.alloc(1)
    characteristicId.writeUInt8(id, 0)
    const buffer = Buffer.concat(
      [
        characteristicId,
        characteristicBuffer
      ],
      characteristicId.length + characteristicBuffer.length
    )

    if (this._updateValueCallback) {
      this._updateValueCallback(buffer)
    }
    return this.RESULT_SUCCESS
  }
}

ble/pm5/characteristic/StrokeData.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Implementation of the StrokeData as defined in:
  https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
  todo: we could calculate all the missing stroke metrics in the RowerEngine
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from '../Pm5Constants.js'
import log from 'loglevel'
import BufferBuilder from '../../BufferBuilder.js'

export default class StrokeData extends bleno.Characteristic {
  constructor (multiplexedCharacteristic) {
    super({
      // id for StrokeData as defined in the spec
      uuid: getFullUUID('0035'),
      value: null,
      properties: ['notify']
    })
    this._updateValueCallback = null
    this._multiplexedCharacteristic = multiplexedCharacteristic
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`StrokeData - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug('StrokeData - central unsubscribed')
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }

  notify (data) {
    if (this._updateValueCallback || this._multiplexedCharacteristic.centralSubscribed()) {
      const bufferBuilder = new BufferBuilder()
      // elapsedTime: UInt24LE in 0.01 sec
      bufferBuilder.writeUInt24LE(Math.round(data.durationTotal * 100))
      // distance: UInt24LE in 0.1 m
      bufferBuilder.writeUInt24LE(Math.round(data.distanceTotal * 10))
      // driveLength: UInt8 in 0.01 m
      bufferBuilder.writeUInt8(0 * 100)
      // driveTime: UInt8 in 0.01 s
      bufferBuilder.writeUInt8(0 * 100)
      // strokeRecoveryTime: UInt16LE in 0.01 s
      bufferBuilder.writeUInt16LE(0 * 100)
      // strokeDistance: UInt16LE in 0.01 s
      bufferBuilder.writeUInt16LE(0 * 100)
      // peakDriveForce: UInt16LE in 0.1 watts
      bufferBuilder.writeUInt16LE(0 * 10)
      // averageDriveForce: UInt16LE in 0.1 watts
      bufferBuilder.writeUInt16LE(0 * 10)
      if (this._updateValueCallback) {
        // workPerStroke is only added if data is not send via multiplexer
        // workPerStroke: UInt16LE
        bufferBuilder.writeUInt16LE(0)
      }
      // strokeCount: UInt16LE
      bufferBuilder.writeUInt16LE(data.strokesTotal)
      if (this._updateValueCallback) {
        this._updateValueCallback(bufferBuilder.getBuffer())
      } else {
        this._multiplexedCharacteristic.notify(0x35, bufferBuilder.getBuffer())
      }
      return this.RESULT_SUCCESS
    }
  }
}

ble/pm5/characteristic/ValueReadCharacteristic.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  A simple Characteristic that gives read and notify access to a static value
  Currently also used as placeholder on a lot of characteristics that are not yet implemented properly
*/
import bleno from '@abandonware/bleno'
import log from 'loglevel'

export default class ValueReadCharacteristic extends bleno.Characteristic {
  constructor (uuid, value, description) {
    super({
      uuid,
      properties: ['read', 'notify'],
      value: null
    })
    this.uuid = uuid
    this._value = Buffer.isBuffer(value) ? value : Buffer.from(value)
    this._description = description
    this._updateValueCallback = null
  }

  onReadRequest (offset, callback) {
    log.debug(`ValueReadRequest: ${this._description ? this._description : this.uuid}`)
    callback(this.RESULT_SUCCESS, this._value.slice(offset, this._value.length))
  }

  onSubscribe (maxValueSize, updateValueCallback) {
    log.debug(`characteristic ${this._description ? this._description : this.uuid} - central subscribed with maxSize: ${maxValueSize}`)
    this._updateValueCallback = updateValueCallback
    return this.RESULT_SUCCESS
  }

  onUnsubscribe () {
    log.debug(`characteristic ${this._description ? this._description : this.uuid} - central unsubscribed`)
    this._updateValueCallback = null
    return this.RESULT_UNLIKELY_ERROR
  }
}

ble/pm5/DeviceInformationService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Provides the required Device Information of the PM5
*/
import bleno from '@abandonware/bleno'
import { constants, getFullUUID } from './Pm5Constants.js'
import ValueReadCharacteristic from './characteristic/ValueReadCharacteristic.js'

export default class DeviceInformationService extends bleno.PrimaryService {
  constructor () {
    super({
      // InformationenService uuid as defined by the PM5 specification
      uuid: getFullUUID('0010'),
      characteristics: [
        // C2 module number string
        new ValueReadCharacteristic(getFullUUID('0011'), constants.model, 'model'),
        // C2 serial number string
        new ValueReadCharacteristic(getFullUUID('0012'), constants.serial, 'serial'),
        // C2 hardware revision string
        new ValueReadCharacteristic(getFullUUID('0013'), constants.hardwareRevision, 'hardwareRevision'),
        // C2 firmware revision string
        new ValueReadCharacteristic(getFullUUID('0014'), constants.firmwareRevision, 'firmwareRevision'),
        // C2 manufacturer name string
        new ValueReadCharacteristic(getFullUUID('0015'), constants.manufacturer, 'manufacturer'),
        // Erg Machine Type
        new ValueReadCharacteristic(getFullUUID('0016'), constants.ergMachineType, 'ergMachineType')
      ]
    })
  }
}

ble/pm5/GapService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Provides all required GAP Characteristics of the PM5
  todo: not sure if this is correct, the normal GAP service has 0x1800
*/
import bleno from '@abandonware/bleno'
import { constants, getFullUUID } from './Pm5Constants.js'
import ValueReadCharacteristic from './characteristic/ValueReadCharacteristic.js'

export default class GapService extends bleno.PrimaryService {
  constructor () {
    super({
      // GAP Service UUID of PM5
      uuid: getFullUUID('0000'),
      characteristics: [
        // GAP device name
        new ValueReadCharacteristic('2A00', constants.name),
        // GAP appearance
        new ValueReadCharacteristic('2A01', [0x00, 0x00]),
        // GAP peripheral privacy
        new ValueReadCharacteristic('2A02', [0x00]),
        // GAP reconnect address
        new ValueReadCharacteristic('2A03', '00:00:00:00:00:00'),
        // Peripheral preferred connection parameters
        new ValueReadCharacteristic('2A04', [0x18, 0x00, 0x18, 0x00, 0x00, 0x00, 0xE8, 0x03])
      ]
    })
  }
}

ble/pm5/Pm5Constants.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Some PM5 specific constants
*/
const constants = {
  serial: '123456789',
  model: 'PM5',
  name: 'PM5 123456789',
  hardwareRevision: '633',
  // see https://www.concept2.com/service/monitors/pm5/firmware for available versions
  firmwareRevision: '207',
  manufacturer: 'Concept2',
  ergMachineType: [0x05]
}

// PM5 uses 128bit UUIDs that are always prefixed and suffixed the same way
function getFullUUID (uuid) {
  return `ce06${uuid}43e511e4916c0800200c9a66`
}

export {
  getFullUUID,
  constants
}

ble/pm5/Pm5ControlService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  The Control service can be used to send control commands to the PM5 device
  todo: not yet wired
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from './Pm5Constants.js'
import ControlTransmit from './characteristic/ControlTransmit.js'
import ControlReceive from './characteristic/ControlReceive.js'

export default class PM5ControlService extends bleno.PrimaryService {
  constructor () {
    super({
      uuid: getFullUUID('0020'),
      characteristics: [
        new ControlReceive(),
        new ControlTransmit()
      ]
    })
  }
}

ble/pm5/Pm5RowingService.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This seems to be the central service to get information about the workout
  This Primary Service provides a lot of stuff that we most certainly do not need to simulate a
  simple PM5 service.

  todo: figure out to which services some common applications subscribe and then just implement those
  // fluid simulation uses GeneralStatus STROKESTATE_DRIVING
  // cloud simulation uses MULTIPLEXER, AdditionalStatus -> currentPace
  // EXR: subscribes to: 'general status', 'additional status', 'additional status 2', 'additional stroke data'
  Might implement:
  * GeneralStatus
  * AdditionalStatus
  * AdditionalStatus2
  * (StrokeData)
  * AdditionalStrokeData
  * and of course the multiplexer
*/
import bleno from '@abandonware/bleno'
import { getFullUUID } from './Pm5Constants.js'
import ValueReadCharacteristic from './characteristic/ValueReadCharacteristic.js'
import MultiplexedCharacteristic from './characteristic/MultiplexedCharacteristic.js'
import GeneralStatus from './characteristic/GeneralStatus.js'
import AdditionalStatus from './characteristic/AdditionalStatus.js'
import AdditionalStatus2 from './characteristic/AdditionalStatus2.js'
import AdditionalStrokeData from './characteristic/AdditionalStrokeData.js'
import StrokeData from './characteristic/StrokeData.js'

export default class PM5RowingService extends bleno.PrimaryService {
  constructor () {
    const multiplexedCharacteristic = new MultiplexedCharacteristic()
    const generalStatus = new GeneralStatus(multiplexedCharacteristic)
    const additionalStatus = new AdditionalStatus(multiplexedCharacteristic)
    const additionalStatus2 = new AdditionalStatus2(multiplexedCharacteristic)
    const strokeData = new StrokeData(multiplexedCharacteristic)
    const additionalStrokeData = new AdditionalStrokeData(multiplexedCharacteristic)
    super({
      uuid: getFullUUID('0030'),
      characteristics: [
        // C2 rowing general status
        generalStatus,
        // C2 rowing additional status
        additionalStatus,
        // C2 rowing additional status 2
        additionalStatus2,
        // C2 rowing general status and additional status samplerate
        new ValueReadCharacteristic(getFullUUID('0034'), 'samplerate', 'samplerate'),
        // C2 rowing stroke data
        strokeData,
        // C2 rowing additional stroke data
        additionalStrokeData,
        // C2 rowing split/interval data
        new ValueReadCharacteristic(getFullUUID('0037'), 'split data', 'split data'),
        // C2 rowing additional split/interval data
        new ValueReadCharacteristic(getFullUUID('0038'), 'additional split data', 'additional split data'),
        // C2 rowing end of workout summary data
        new ValueReadCharacteristic(getFullUUID('0039'), 'workout summary', 'workout summary'),
        // C2 rowing end of workout additional summary data
        new ValueReadCharacteristic(getFullUUID('003A'), 'additional workout summary', 'additional workout summary'),
        // C2 rowing heart rate belt information
        new ValueReadCharacteristic(getFullUUID('003B'), 'heart rate belt information', 'heart rate belt information'),
        // C2 force curve data
        new ValueReadCharacteristic(getFullUUID('003D'), 'force curve data', 'force curve data'),
        // C2 multiplexed information
        multiplexedCharacteristic
      ]
    })
    this.generalStatus = generalStatus
    this.additionalStatus = additionalStatus
    this.additionalStatus2 = additionalStatus2
    this.strokeData = strokeData
    this.additionalStrokeData = additionalStrokeData
    this.multiplexedCharacteristic = multiplexedCharacteristic
  }

  notifyData (type, data) {
    if (type === 'strokeFinished' || type === 'metricsUpdate') {
      this.generalStatus.notify(data)
      this.additionalStatus.notify(data)
      this.additionalStatus2.notify(data)
      this.strokeData.notify(data)
      this.additionalStrokeData.notify(data)
    } else if (type === 'strokeStateChanged') {
      // the stroke state is delivered via the GeneralStatus Characteristic, so we only need to notify that one
      this.generalStatus.notify(data)
    }
  }
}

ble/BufferBuilder.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  A buffer builder that simplifies the creation of payloads for BLE messages
*/
import log from 'loglevel'

export default class BufferBuilder {
  constructor () {
    this._dataArray = []
  }

  writeUInt8 (value) {
    const buffer = Buffer.alloc(1)
    try {
      buffer.writeUInt8(value || 0)
    } catch (error) {
      log.warn(error)
    }
    this._dataArray.push(buffer)
  }

  writeUInt16LE (value) {
    const buffer = Buffer.alloc(2)
    try {
      buffer.writeUInt16LE(value || 0)
    } catch (error) {
      log.warn(error)
    }
    this._dataArray.push(buffer)
  }

  writeUInt24LE (value) {
    const _value = value || 0
    const buffer = Buffer.alloc(3)
    if (value > 0xffffff || value < 0) {
      log.warn(new RangeError(`The value of "value" is out of range. It must be >= 0 and <= ${0xffffff}. Received ${value}`))
    } else {
      try {
        buffer.writeUInt8(_value & 255)
        buffer.writeUInt16LE(_value >> 8, 1)
      } catch (error) {
        log.warn(error)
      }
    }
    this._dataArray.push(buffer)
  }

  getBuffer () {
    return Buffer.concat(this._dataArray)
  }
}

ble/BufferBuilder.test.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor
*/
import { test } from 'uvu'
import * as assert from 'uvu/assert'
import BufferBuilder from './BufferBuilder.js'
import log from 'loglevel'
log.setLevel(log.levels.SILENT)

test('valid max UInts should produce correct buffer', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt8(255)
  buffer.writeUInt16LE(65535)
  buffer.writeUInt24LE(16777215)
  assert.equal(buffer.getBuffer(), Buffer.from([0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF]))
})

test('valid min UInts should produce correct buffer', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt8(0)
  buffer.writeUInt16LE(0)
  buffer.writeUInt24LE(0)
  assert.equal(buffer.getBuffer(), Buffer.from([0x0, 0x0, 0x0, 0x0, 0x0, 0x0]))
})

test('negative UInt8 should produce 1 bit buffer of 0x0', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt8(-1)
  assert.equal(buffer.getBuffer(), Buffer.from([0x0]))
})

test('negative UInt16LE should produce 2 bit buffer of 0x0', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt16LE(-1)
  assert.equal(buffer.getBuffer(), Buffer.from([0x0, 0x0]))
})

test('negative writeUInt24LE should produce 3 bit buffer of 0x0', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt24LE(-1)
  assert.equal(buffer.getBuffer(), Buffer.from([0x0, 0x0, 0x0]))
})

test('invalid datatype value UInt16LE should produce 2 bit buffer of 0x0', () => {
  const buffer = new BufferBuilder()
  buffer.writeUInt16LE(new Map())
  assert.equal(buffer.getBuffer(), Buffer.from([0x0, 0x0]))
})

test.run()

ble/CentralManager.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This manager creates a Bluetooth Low Energy (BLE) Central that listens
  and subscribes to heart rate services
*/
import log from 'loglevel'
import EventEmitter from 'node:events'
import Noble from '@abandonware/noble/lib/noble.js'
import NobleBindings from '@abandonware/noble/lib/hci-socket/bindings.js'

// We are using peripherals and centrals at the same time (with bleno and noble).
// The libraries do not play nice together in this scenario when they see peripherals
// from each other via the HCI-Socket.
// This is a quick patch for two handlers in noble that would otherwise throw warnings
// when they see a peripheral or handle that is managed by bleno

// START of noble patch
Noble.prototype.onRssiUpdate = function (peripheralUuid, rssi) {
  const peripheral = this._peripherals[peripheralUuid]

  if (peripheral) {
    peripheral.rssi = rssi
    peripheral.emit('rssiUpdate', rssi)
  }
}

NobleBindings.prototype.onDisconnComplete = function (handle, reason) {
  const uuid = this._handles[handle]

  if (uuid) {
    this._aclStreams[handle].push(null, null)
    this._gatts[handle].removeAllListeners()
    this._signalings[handle].removeAllListeners()

    delete this._gatts[uuid]
    delete this._gatts[handle]
    delete this._signalings[uuid]
    delete this._signalings[handle]
    delete this._aclStreams[handle]
    delete this._handles[uuid]
    delete this._handles[handle]

    this.emit('disconnect', uuid)
  }
}

const noble = new Noble(new NobleBindings())
// END of noble patch

function createCentralManager () {
  const emitter = new EventEmitter()
  let batteryLevel

  noble.on('stateChange', (state) => {
    if (state === 'poweredOn') {
      // search for heart rate service
      noble.startScanning(['180d'], false)
    } else {
      noble.stopScanning()
    }
  })

  noble.on('discover', (peripheral) => {
    noble.stopScanning()
    connectHeartratePeripheral(peripheral)
  })

  function connectHeartratePeripheral (peripheral) {
    // connect to the heart rate sensor
    peripheral.connect((error) => {
      if (error) {
        log.error(error)
        return
      }
      log.info(`heart rate peripheral connected, name: '${peripheral.advertisement?.localName}', id: ${peripheral.id}`)
      subscribeToHeartrateMeasurement(peripheral)
    })

    peripheral.once('disconnect', () => {
      // todo: figure out if we have to dispose the peripheral somehow to prevent memory leaks
      log.info('heart rate peripheral disconnected, searching new one')
      batteryLevel = undefined
      noble.startScanning(['180d'], false)
    })
  }

  // see https://www.bluetooth.com/specifications/specs/heart-rate-service-1-0/
  function subscribeToHeartrateMeasurement (peripheral) {
    const heartrateMeasurementUUID = '2a37'
    const batteryLevelUUID = '2a19'

    peripheral.discoverSomeServicesAndCharacteristics([], [heartrateMeasurementUUID, batteryLevelUUID],
      (error, services, characteristics) => {
        if (error) {
          log.error(error)
          return
        }

        const heartrateMeasurementCharacteristic = characteristics.find(
          characteristic => characteristic.uuid === heartrateMeasurementUUID
        )

        const batteryLevelCharacteristic = characteristics.find(
          characteristic => characteristic.uuid === batteryLevelUUID
        )

        if (heartrateMeasurementCharacteristic !== undefined) {
          heartrateMeasurementCharacteristic.notify(true, (error) => {
            if (error) {
              log.error(error)
              return
            }

            heartrateMeasurementCharacteristic.on('data', (data, isNotification) => {
              const buffer = Buffer.from(data)
              const flags = buffer.readUInt8(0)
              // bits of the feature flag:
              // 0: Heart Rate Value Format
              // 1 + 2: Sensor Contact Status
              // 3: Energy Expended Status
              // 4: RR-Interval
              const heartrateUint16LE = flags & 0b1

              // from the specs:
              // While most human applications require support for only 255 bpm or less, special
              // applications (e.g. animals) may require support for higher bpm values.
              // If the Heart Rate Measurement Value is less than or equal to 255 bpm a UINT8 format
              // should be used for power savings.
              // If the Heart Rate Measurement Value exceeds 255 bpm a UINT16 format shall be used.
              const heartrate = heartrateUint16LE ? buffer.readUInt16LE(1) : buffer.readUInt8(1)
              emitter.emit('heartrateMeasurement', { heartrate, batteryLevel })
            })
          })
        }

        if (batteryLevelCharacteristic !== undefined) {
          batteryLevelCharacteristic.notify(true, (error) => {
            if (error) {
              log.error(error)
              return
            }

            batteryLevelCharacteristic.on('data', (data, isNotification) => {
              const buffer = Buffer.from(data)
              batteryLevel = buffer.readUInt8(0)
            })
          })
        }
      })
  }

  return Object.assign(emitter, {
  })
}

export { createCentralManager }

ble/CentralServive.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Starts the central manager in a forked thread since noble does not like
  to run in the same thread as bleno
*/
import { createCentralManager } from './CentralManager.js'
import process from 'process'
import config from '../tools/ConfigManager.js'
import log from 'loglevel'

log.setLevel(config.loglevel.default)
const centralManager = createCentralManager()

centralManager.on('heartrateMeasurement', (heartrateMeasurement) => {
  process.send(heartrateMeasurement)
})

ble/FtmsPeripheral.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Creates a Bluetooth Low Energy (BLE) Peripheral with all the Services that are required for
  a Fitness Machine Device

  Relevant parts from https://www.bluetooth.com/specifications/specs/fitness-machine-profile-1-0/
  The Fitness Machine shall instantiate one and only one Fitness Machine Service as Primary Service
  The User Data Service, if supported, shall be instantiated as a Primary Service.
  The Fitness Machine may instantiate the Device Information Service
  (Manufacturer Name String, Model Number String)
*/
import bleno from '@abandonware/bleno'
import FitnessMachineService from './ftms/FitnessMachineService.js'
// import DeviceInformationService from './ftms/DeviceInformationService.js'
import config from '../tools/ConfigManager.js'
import log from 'loglevel'

function createFtmsPeripheral (controlCallback, options) {
  const peripheralName = options?.simulateIndoorBike ? config.ftmsBikePeripheralName : config.ftmsRowerPeripheralName
  const fitnessMachineService = new FitnessMachineService(options, controlPointCallback)
  // const deviceInformationService = new DeviceInformationService()

  bleno.on('stateChange', (state) => {
    triggerAdvertising(state)
  })

  bleno.on('advertisingStart', (error) => {
    if (!error) {
      bleno.setServices(
        // [fitnessMachineService, deviceInformationService],
        [fitnessMachineService],
        (error) => {
          if (error) log.error(error)
        })
    }
  })

  bleno.on('accept', (clientAddress) => {
    log.debug(`ble central connected: ${clientAddress}`)
    bleno.updateRssi()
  })

  bleno.on('disconnect', (clientAddress) => {
    log.debug(`ble central disconnected: ${clientAddress}`)
  })

  bleno.on('platform', (event) => {
    log.debug('platform', event)
  })
  bleno.on('addressChange', (event) => {
    log.debug('addressChange', event)
  })
  bleno.on('mtuChange', (event) => {
    log.debug('mtuChange', event)
  })
  bleno.on('advertisingStartError', (event) => {
    log.debug('advertisingStartError', event)
  })
  bleno.on('servicesSetError', (event) => {
    log.debug('servicesSetError', event)
  })
  bleno.on('rssiUpdate', (event) => {
    log.debug('rssiUpdate', event)
  })

  function controlPointCallback (event) {
    const obj = {
      req: event,
      res: {}
    }
    if (controlCallback) controlCallback(obj)
    return obj.res
  }

  function destroy () {
    return new Promise((resolve) => {
      bleno.disconnect()
      bleno.removeAllListeners()
      bleno.stopAdvertising(resolve)
    })
  }

  function triggerAdvertising (eventState) {
    const activeState = eventState || bleno.state
    if (activeState === 'poweredOn') {
      bleno.startAdvertising(
        peripheralName,
        // [fitnessMachineService.uuid, deviceInformationService.uuid],
        [fitnessMachineService.uuid],
        (error) => {
          if (error) log.error(error)
        }
      )
    } else {
      bleno.stopAdvertising()
    }
  }

  // present current rowing metrics to FTMS central
  function notifyData (type, data) {
    if (type === 'strokeFinished' || type === 'metricsUpdate') {
      fitnessMachineService.notifyData(data)
    }
  }

  // present current rowing status to FTMS central
  function notifyStatus (status) {
    fitnessMachineService.notifyStatus(status)
  }

  return {
    triggerAdvertising,
    notifyData,
    notifyStatus,
    destroy
  }
}

export { createFtmsPeripheral }

ble/PeripheralManager.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  This manager creates the different Bluetooth Low Energy (BLE) Peripherals and allows
  switching between them
*/
import config from '../tools/ConfigManager.js'
import { createFtmsPeripheral } from './FtmsPeripheral.js'
import { createPm5Peripheral } from './Pm5Peripheral.js'
import log from 'loglevel'
import EventEmitter from 'node:events'

const modes = ['FTMS', 'FTMSBIKE', 'PM5']
function createPeripheralManager () {
  const emitter = new EventEmitter()
  let peripheral
  let mode

  createPeripheral(config.bluetoothMode)

  function getPeripheral () {
    return peripheral
  }

  function getPeripheralMode () {
    return mode
  }

  function switchPeripheralMode (newMode) {
    // if now mode was passed, select the next one from the list
    if (newMode === undefined) {
      newMode = modes[(modes.indexOf(mode) + 1) % modes.length]
    }
    createPeripheral(newMode)
  }

  function notifyMetrics (type, metrics) {
    peripheral.notifyData(type, metrics)
  }

  function notifyStatus (status) {
    peripheral.notifyStatus(status)
  }

  async function createPeripheral (newMode) {
    if (peripheral) {
      await peripheral.destroy()
    }

    if (newMode === 'PM5') {
      log.info('bluetooth profile: Concept2 PM5')
      peripheral = createPm5Peripheral(controlCallback)
      mode = 'PM5'
    } else if (newMode === 'FTMSBIKE') {
      log.info('bluetooth profile: FTMS Indoor Bike')
      peripheral = createFtmsPeripheral(controlCallback, {
        simulateIndoorBike: true
      })
      mode = 'FTMSBIKE'
    } else {
      log.info('bluetooth profile: FTMS Rower')
      peripheral = createFtmsPeripheral(controlCallback, {
        simulateIndoorBike: false
      })
      mode = 'FTMS'
    }
    peripheral.triggerAdvertising()

    emitter.emit('control', {
      req: {
        name: 'peripheralMode',
        peripheralMode: mode
      }
    })
  }

  function controlCallback (event) {
    emitter.emit('control', event)
  }

  return Object.assign(emitter, {
    getPeripheral,
    getPeripheralMode,
    switchPeripheralMode,
    notifyMetrics,
    notifyStatus
  })
}

export { createPeripheralManager }

ble/Pm5PeripherManager.js
'use strict'
/*
  Open Rowing Monitor, https://github.com/laberning/openrowingmonitor

  Creates a Bluetooth Low Energy (BLE) Peripheral with all the Services that are used by the
  Concept2 PM5 rowing machine.

  see: https://www.concept2.co.uk/files/pdf/us/monitors/PM5_BluetoothSmartInterfaceDefinition.pdf
*/
import bleno from '@abandonware/bleno'
import { constants } from './pm5/Pm5Constants.js'
import DeviceInformationService from './pm5/DeviceInformationService.js'
import GapService from './pm5/GapService.js'
import log from 'loglevel'
import Pm5ControlService from './pm5/Pm5ControlService.js'
import Pm5RowingService from './pm5/Pm5RowingService.js'

function createPm5Peripheral (controlCallback, options) {
  const peripheralName = constants.name
  const deviceInformationService = new DeviceInformationService()
  const gapService = new GapService()
  const controlService = new Pm5ControlService()
  const rowingService = new Pm5RowingService()

  bleno.on('stateChange', (state) => {
    triggerAdvertising(state)
  })

  bleno.on('advertisingStart', (error) => {
    if (!error) {
      bleno.setServices(
        [gapService, deviceInformationService, controlService, rowingService],
        (error) => {
          if (error) log.error(error)
        })
    }
  })

  bleno.on('accept', (clientAddress) => {
    log.debug(`ble central connected: ${clientAddress}`)
    bleno.updateRssi()
  })

  bleno.on('disconnect', (clientAddress) => {
    log.debug(`ble central disconnected: ${clientAddress}`)
  })

  bleno.on('platform', (event) => {
    log.debug('platform', event)
  })
  bleno.on('addressChange', (event) => {
    log.debug('addressChange', event)
  })
  bleno.on('mtuChange', (event) => {
    log.debug('mtuChange', event)
  })
  bleno.on('advertisingStartError', (event) => {
    log.debug('advertisingStartError', event)
  })
  bleno.on('servicesSetError', (event) => {
    log.debug('servicesSetError', event)
  })
  bleno.on('rssiUpdate', (event) => {
    log.debug('rssiUpdate', event)
  })

  function destroy () {
    return new Promise((resolve) => {
      bleno.disconnect()
      bleno.removeAllListeners()
      bleno.stopAdvertising(resolve)
    })
  }

  function triggerAdvertising (eventState) {
    const activeState = eventState || bleno.state
    if (activeState === 'poweredOn') {
      bleno.startAdvertising(
        peripheralName,
        [gapService.uuid],
        (error) => {
          if (error) log.error(error)
        }
      )
    } else {
      bleno.stopAdvertising()
    }
  }

  // present current rowing metrics to C2-PM5 central
  function notifyData (type, data) {
    rowingService.notifyData(type, data)
  }

  // present current rowing status to C2-PM5 central
  function notifyStatus (status) {
  }

  return {
    triggerAdvertising,
    notifyData,
    notifyStatus,
    destroy
  }
}

export { createPm5Peripheral }
