modules/bles_service/BleManager.h
#ifndef BLE_MANAGER_H
#define BLE_MANAGER_H

#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/gap.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/sys/printk.h>

class BleManager {
public:
    void init();
    void startAdvertising();

    // Check if a device is currently connected
    bool isConnected();

private:
    static void onConnected(struct bt_conn *conn, uint8_t err);
    static void onDisconnected(struct bt_conn *conn, uint8_t reason);

    // Track the active connection
    static struct bt_conn *current_conn;
};

#endif // BLE_MANAGER_H

modules/bles_service/BleManager.cpp
#include "BleManager.h"
#include "FTMS.h" // To get UUID definitions

struct bt_conn *BleManager::current_conn = nullptr;

// GAP Connection Callbacks
BT_CONN_CB_DEFINE(conn_callbacks) = {
    .connected = BleManager::onConnected,
    .disconnected = BleManager::onDisconnected,
};

// -----------------------------------------------------------------------------
// ADVERTISING DATA
// -----------------------------------------------------------------------------
// 1. Flags: General Discoverable
// 2. UUIDs: We MUST advertise the FTMS Service UUID (0x1826)
static const struct bt_data ad[] = {
    BT_DATA_BYTES(BT_DATA_FLAGS, (BT_LE_AD_GENERAL | BT_LE_AD_NO_BREDR)),
    BT_DATA_BYTES(BT_DATA_UUID16_ALL,
                  BT_UUID_16_ENCODE(BT_UUID_FTMS_VAL)) // 0x1826
};

// Scan Response: Show the Device Name
static const struct bt_data sd[] = {
    BT_DATA(BT_DATA_NAME_COMPLETE, CONFIG_BT_DEVICE_NAME, sizeof(CONFIG_BT_DEVICE_NAME) - 1),
};

void BleManager::init() {
    int err = bt_enable(NULL);
    if (err) {
        printk("Bluetooth init failed (err %d)\n", err);
        return;
    }
    printk("Bluetooth initialized\n");
    startAdvertising();
}

void BleManager::startAdvertising() {
    int err = bt_le_adv_start(BT_LE_ADV_CONN_NAME, ad, ARRAY_SIZE(ad), sd, ARRAY_SIZE(sd));
    if (err) {
        printk("Advertising failed to start (err %d)\n", err);
        return;
    }
    printk("Advertising successfully started\n");
}

bool BleManager::isConnected() {
    return (current_conn != nullptr);
}

void BleManager::onConnected(struct bt_conn *conn, uint8_t err) {
    if (err) {
        printk("Connection failed (err 0x%02x)\n", err);
    } else {
        printk("Connected\n");
        current_conn = bt_conn_ref(conn);
    }
}

void BleManager::onDisconnected(struct bt_conn *conn, uint8_t reason) {
    printk("Disconnected (reason 0x%02x)\n", reason);
    if (current_conn) {
        bt_conn_unref(current_conn);
        current_conn = nullptr;
    }
}

modules/bles_service/FTMS.h
#ifndef FTMS_H
#define FTMS_H

#include <zephyr/types.h>
#include <stddef.h>
#include <string.h>
#include <errno.h>
#include <zephyr/sys/printk.h>
#include <zephyr/sys/byteorder.h>
#include <zephyr/bluetooth/bluetooth.h>
#include <zephyr/bluetooth/hci.h>
#include <zephyr/bluetooth/conn.h>
#include <zephyr/bluetooth/uuid.h>
#include <zephyr/bluetooth/gatt.h>

#include "RowingData.h"

// UUID definitions for FTMS
#define BT_UUID_FTMS_VAL             0x1826
#define BT_UUID_FTMS                 BT_UUID_DECLARE_16(BT_UUID_FTMS_VAL)
#define BT_UUID_ROWER_DATA_VAL       0x2AD1
#define BT_UUID_ROWER_DATA           BT_UUID_DECLARE_16(BT_UUID_ROWER_DATA_VAL)
#define BT_UUID_FITNESS_MACHINE_FEATURE_VAL 0x2ACC
#define BT_UUID_FITNESS_MACHINE_FEATURE     BT_UUID_DECLARE_16(BT_UUID_FITNESS_MACHINE_FEATURE_VAL)

class FTMS {
public:
    /**
     * @brief Initialize the FTMS Service (Advertises capabilities)
     * call this once at startup
     */
    void init();

    /**
     * @brief Sends a notification with the latest rowing data
     * @param data The struct from your RowingEngine
     */
    void notifyRowingData(const RowingData& data);

private:
    // Helper to check if a client has subscribed to notifications
    bool isNotifyEnabled();
};

#endif // FTMS_H

modules/bles_service/FTMS.cpp
#include "FTMS.h"

// -----------------------------------------------------------------------------
// 1. Define the GATT Service using Zephyr Macros
// -----------------------------------------------------------------------------

// FTMS Features: Read-only.
// Bit 4 = Rower Supported.
static const uint32_t ftms_feature = 0x0000082D | BIT(4);

static ssize_t read_feature(struct bt_conn *conn, const struct bt_gatt_attr *attr,
			    void *buf, uint16_t len, uint16_t offset)
{
	return bt_gatt_attr_read(conn, attr, buf, len, offset, &ftms_feature,
				 sizeof(ftms_feature));
}

// Configuration Change Callback (CCCD) - Tracks if client subscribed to notifications
static bool notify_enabled = false;
static void rower_ccc_cfg_changed(const struct bt_gatt_attr *attr, uint16_t value)
{
	notify_enabled = (value == BT_GATT_CCC_NOTIFY);
    printk("FTMS Notifications %s\n", notify_enabled ? "ENABLED" : "DISABLED");
}

// Define the Service Layout
BT_GATT_SERVICE_DEFINE(ftms_svc,
    BT_GATT_PRIMARY_SERVICE(BT_UUID_FTMS),

    // Characteristic: Rower Data (0x2AD1) - Notify Only
    BT_GATT_CHARACTERISTIC(BT_UUID_ROWER_DATA,
                           BT_GATT_CHRC_NOTIFY,
                           BT_GATT_PERM_NONE,
                           NULL, NULL, NULL),
    BT_GATT_CCC(rower_ccc_cfg_changed, BT_GATT_PERM_READ | BT_GATT_PERM_WRITE),

    // Characteristic: Fitness Machine Feature (0x2ACC) - Read Only
    BT_GATT_CHARACTERISTIC(BT_UUID_FITNESS_MACHINE_FEATURE,
                           BT_GATT_CHRC_READ,
                           BT_GATT_PERM_READ,
                           read_feature, NULL, NULL)
);

// -----------------------------------------------------------------------------
// 2. Class Implementation
// -----------------------------------------------------------------------------

void FTMS::init() {
    // Zephyr handles GATT initialization automatically via the macro.
    // This function is here if you need to set initial values or debug logs.
    printk("FTMS Service Initialized\n");
}

bool FTMS::isNotifyEnabled() {
    return notify_enabled;
}

void FTMS::notifyRowingData(const RowingData& data) {
    if (!notify_enabled) return;

    /* FLAG MAPPING (UINT16):
       Bit 0: 0 (Stroke Rate/Count Present)
       Bit 1: 1 (Avg Stroke Rate Present)
       Bit 2: 1 (Total Distance Present)
       Bit 3: 1 (Inst Pace Present)
       Bit 4: 1 (Avg Pace Present)
       Bit 5: 1 (Inst Power Present)
       Bit 6: 1 (Avg Power Present)
       Bit 11: 1 (Elapsed Time Present)
    */
    uint16_t flags = 0;
    flags |= BIT(1);
    flags |= BIT(2);
    flags |= BIT(3);
    flags |= BIT(4);
    flags |= BIT(5);
    flags |= BIT(6);
    flags |= BIT(11);

    uint8_t buffer[30];
    uint8_t cursor = 0;

    // [1] Flags (UINT16)
    sys_put_le16(flags, &buffer[cursor]);
    cursor += 2;

    // [2] Inst. Stroke Rate (UINT8 - 0.5 unit) & Stroke Count (UINT16)
    // Present because Bit 0 is 0
    buffer[cursor++] = (uint8_t)(data.spm * 2.0);
    sys_put_le16((uint16_t)data.strokeCount, &buffer[cursor]);
    cursor += 2;

    // [3] Average Stroke Rate (UINT8 - 0.5 unit)
    // Present because Bit 1 is 1
    buffer[cursor++] = (uint8_t)(data.avgSpm * 2.0);

    // [4] Total Distance (UINT24 - Meters)
    // Present because Bit 2 is 1
    sys_put_le24((uint32_t)data.distance, &buffer[cursor]);
    cursor += 3;

    // [5] Instantaneous Pace (UINT16 - Seconds per 500m)
    // Present because Bit 3 is 1
    uint16_t instPace = (data.speed > 0.1) ? (uint16_t)(500.0 / data.speed) : 0;
    sys_put_le16(instPace, &buffer[cursor]);
    cursor += 2;

    // [6] Average Pace (UINT16 - Seconds per 500m)
    // Present because Bit 4 is 1
    uint16_t avgPace = (data.avgSpeed > 0.1) ? (uint16_t)(500.0 / data.avgSpeed) : 0;
    sys_put_le16(avgPace, &buffer[cursor]);
    cursor += 2;

    // [7] Instantaneous Power (SINT16 - Watts)
    // Present because Bit 5 is 1
    sys_put_le16((int16_t)data.power, &buffer[cursor]);
    cursor += 2;

    // [8] Average Power (SINT16 - Watts)
    // Present because Bit 6 is 1
    sys_put_le16((int16_t)data.avgPower, &buffer[cursor]);
    cursor += 2;

    // [9] Elapsed Time (UINT16 - Seconds)
    // Present because Bit 11 is 1
    sys_put_le16((uint16_t)data.totalTime, &buffer[cursor]);
    cursor += 2;

    // Total buffer size used will be 18 bytes
    bt_gatt_notify(NULL, &ftms_svc.attrs[2], buffer, cursor);
}


}

modules/bles_service/RowerBridge.h
#ifndef ROWER_BRIDGE_H
#define ROWER_BRIDGE_H

#include "RowingEngine.h"
#include "FTMS.h"

class RowerBridge {
public:
    RowerBridge(RowingEngine& engine, FTMS& service);

    /**
     * @brief Call this in your main loop to handle data updates
     */
    void update();

private:
    RowingEngine& m_engine;
    FTMS& m_service;

    // Rate limiting: We don't want to spam BLE (max 2-4 Hz is good)
    uint32_t last_update_time = 0;
    const uint32_t UPDATE_INTERVAL_MS = 500; // 2 updates per second
};

#endif // ROWER_BRIDGE_H

modules/bles_service/RowerBridge.cpp
#include "RowerBridge.h"
#include <zephyr/kernel.h> // For k_uptime_get()

RowerBridge::RowerBridge(RowingEngine& engine, FTMS& service)
    : m_engine(engine), m_service(service) {}

void RowerBridge::update() {
    // 1. Check if enough time has passed (Rate Limiting)
    uint32_t now = k_uptime_get_32();
    if ((now - last_update_time) < UPDATE_INTERVAL_MS) {
        return;
    }
    last_update_time = now;

    // 2. Get Fresh Data from Physics Engine
    RowingData data = m_engine.getData();

    // 3. Send to BLE Service
    // The Service handles the check for "isNotifyEnabled", so we can just call it.
    m_service.notifyRowingData(data);
}

modules/hardware_driver/GpioTimerService.h
#pragma once

#include <zephyr/kernel.h>
#include <zephyr/drivers/gpio.h>
#include "RowingEngine.h"

#define IMPULSE_QUEUE_SIZE 10

class GpioTimerService {
public:
    explicit GpioTimerService(RowingEngine& engine);
    int init();

private:
    RowingEngine& engine;

    // GPIO structs
    struct gpio_dt_spec sensorSpec;
    struct gpio_callback pinCbData;

    // Timing State
    uint32_t lastCycleTime;
    bool isFirstPulse;

    // IPC: Message Queue
    struct k_msgq impulseQueue;
    char __aligned(8) impulseQueueBuffer[IMPULSE_QUEUE_SIZE * sizeof(double)];

    // THREAD DATA
    // We keep the struct here, but the STACK will be defined in the .cpp file
    struct k_thread physicsThreadData;

    // The Loop Function
    void physicsLoop();

    // Static entry points
    static void physicsThreadEntryPoint(void* p1, void* p2, void* p3);
    static void interruptHandlerStatic(const struct device *dev, struct gpio_callback *cb, uint32_t pins);

    void handleInterrupt();
};

modules/hardware_driver/GpioTimerService.cpp
#include "GpioTimerService.h"
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(GpioTimerService, LOG_LEVEL_INF);

K_THREAD_STACK_DEFINE(physicsThreadStack, 2048);

#define PHYSICS_PRIORITY 5

// 1. GLOBAL STATIC POINTER (Singleton-ish access for ISR)
static GpioTimerService* instance = nullptr;

GpioTimerService::GpioTimerService(RowingEngine& eng)
    : engine(eng),
      sensorSpec(GPIO_DT_SPEC_GET(DT_ALIAS(impulse_sensor), gpios)),
      lastCycleTime(0),
      isFirstPulse(true) {

    // Set the global instance to 'this'
    instance = this;

    k_msgq_init(&impulseQueue, impulseQueueBuffer, sizeof(double), IMPULSE_QUEUE_SIZE);

    k_thread_create(&physicsThreadData,
                    physicsThreadStack,
                    K_THREAD_STACK_SIZEOF(physicsThreadStack),
                    physicsThreadEntryPoint,
                    this, NULL, NULL,
                    PHYSICS_PRIORITY,
                    0,
                    K_NO_WAIT);
}

int GpioTimerService::init() {
    if (!gpio_is_ready_dt(&sensorSpec)) {
        LOG_ERR("GPIO device not ready");
        return -1;
    }

    int ret = gpio_pin_configure_dt(&sensorSpec, GPIO_INPUT);
    if (ret < 0) return ret;

    ret = gpio_pin_interrupt_configure_dt(&sensorSpec, GPIO_INT_EDGE_TO_ACTIVE);
    if (ret < 0) return ret;

    gpio_init_callback(&pinCbData, interruptHandlerStatic, BIT(sensorSpec.pin));
    gpio_add_callback(sensorSpec.port, &pinCbData);

    LOG_INF("GpioTimerService initialized on pin %d", sensorSpec.pin);
    return 0;
}

void GpioTimerService::physicsThreadEntryPoint(void* p1, void* p2, void* p3) {
    GpioTimerService* self = static_cast<GpioTimerService*>(p1);
    self->physicsLoop();
}

void GpioTimerService::physicsLoop() {
    double dt;
    while (true) {
        if (k_msgq_get(&impulseQueue, &dt, K_FOREVER) == 0) {
            engine.handleRotationImpulse(dt);
        }
    }
}

// 2. FIXED ISR TRAMPOLINE (No more CONTAINER_OF)
void GpioTimerService::interruptHandlerStatic(const struct device *dev, struct gpio_callback *cb, uint32_t pins) {
    // Directly use the static instance pointer
    if (instance) {
        instance->handleInterrupt();
    }
}

void GpioTimerService::handleInterrupt() {
    uint32_t currentCycles = k_cycle_get_32();

    if (isFirstPulse) {
        lastCycleTime = currentCycles;
        isFirstPulse = false;
        return;
    }

    uint32_t deltaCycles = currentCycles - lastCycleTime;
    lastCycleTime = currentCycles;

    double dt = (double)deltaCycles / (double)sys_clock_hw_cycles_per_sec();

    k_msgq_put(&impulseQueue, &dt, K_NO_WAIT);
}

modules/physics_engine/MovingAverager.h
#pragma once
#include <algorithm>
#include <zephyr/kernel.h> // Required to see CONFIG_ macros

// ----------------------------------------------------------------------
// Calculate the exact memory needed at Compile Time
// ----------------------------------------------------------------------

// 1. Determine the size needed for Drag Factor (if enabled)
#ifdef CONFIG_ORM_AUTO_ADJUST_DRAG_FACTOR
    #define _DRAG_SIZE CONFIG_ORM_DAMPING_CONSTANT_SMOOTING
#else
    #define _DRAG_SIZE 0
#endif

// 2. Determine the size needed for Flank Detection
#define _FLANK_SIZE CONFIG_ORM_SMOOTHING

// 3. Set the Capacity to the LARGER of the two
#if _DRAG_SIZE > _FLANK_SIZE
    #define MAX_AVERAGER_CAPACITY _DRAG_SIZE
#else
    #define MAX_AVERAGER_CAPACITY _FLANK_SIZE
#endif

// ----------------------------------------------------------------------

class MovingAverager {
private:
    // Now this array is exactly as big as it needs to be, and no bigger.
    double dataPoints[MAX_AVERAGER_CAPACITY];
    int length;
    double currAve;

public:
    MovingAverager(int requestedLength, double initValue);
    void pushValue(double dataPoint);
    void replaceLastPushedValue(double dataPoint);
    double getAverage();
    void reset(double initValue);
};

modules/physics_engine/MovingAverager.cpp
#include "MovingAverager.h"
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(MovingAverager, LOG_LEVEL_DBG);

MovingAverager::MovingAverager(int requestedLength, double initValue) {
    // Safety Check:
    // If logic somewhere requests a size larger than we allocated,
    // we clamp it to prevent memory corruption (buffer overflow).
    if (requestedLength > MAX_AVERAGER_CAPACITY) {
        LOG_WRN("Requested size %d > Max Capacity %d. Clamping.", requestedLength, MAX_AVERAGER_CAPACITY);
        length = MAX_AVERAGER_CAPACITY;
    } else {
        length = requestedLength;
    }
    reset(initValue);
}

void MovingAverager::pushValue(double dataPoint) {
    // Standard shift logic
    currAve = currAve+((dataPoint-dataPoints[length-1])/length);
    for (int i = length - 1; i > 0; i--) {
        dataPoints[i] = dataPoints[i - 1];
    }
    dataPoints[0] = dataPoint;
}

void MovingAverager::replaceLastPushedValue(double dataPoint) {
    currAve = currAve+((dataPoint-dataPoints[0])/length);
    dataPoints[0] = dataPoint;
}

double MovingAverager::getAverage() {
    return currAve;
}

void MovingAverager::reset(double initValue) {
    for (int i = 0; i < length; i++) {
        dataPoints[i] = initValue;
    }
    currAve = initValue;
}

modules/physics_engine/MovingFlankDetector.h
#pragma once

#include <cmath>
#include <cstdint>
#include <zephyr/kernel.h>

#include "MovingAverager.h"
#include "RowingSettings.h"

// Define the array size based on Kconfig.
#define FLANK_ARRAY_SIZE (CONFIG_ORM_FLANK_LENGTH + 1)

class MovingFlankDetector {
private:
    RowingSettings settings;
    MovingAverager movingAverage;

    // Fixed-size arrays (Stack allocated). No std::vector!
    double dirtyDataPoints[FLANK_ARRAY_SIZE];
    double cleanDataPoints[FLANK_ARRAY_SIZE];
    double angularVelocity[FLANK_ARRAY_SIZE];
    double angularAcceleration[FLANK_ARRAY_SIZE];

    double angularDisplacementPerImpulse;
    int numberOfSequentialCorrections;
    int maxNumberOfSequentialCorrections;

public:
    explicit MovingFlankDetector(RowingSettings rowerSettings);

    void pushValue(double dataPoint);

    // State Checks
    bool isFlywheelPowered();
    bool isFlywheelUnpowered();

    // Getters
    double timeToBeginOfFlank();
    double noImpulsesToBeginFlank();
    double impulseLengthAtBeginFlank();
    double accelerationAtBeginOfFlank();
};

modules/physics_engine/MovingFlankDetector.cpp
#include "MovingFlankDetector.h"
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(MovingFlankDetector, LOG_LEVEL_DBG);

MovingFlankDetector::MovingFlankDetector(RowingSettings rowerSettings)
    : settings(rowerSettings),
      movingAverage(rowerSettings.smoothing, rowerSettings.maximumTimeBetweenImpulses) {

    angularDisplacementPerImpulse = (2.0 * 3.14159265359) / settings.numOfImpulsesPerRevolution;

    // Initialize arrays with loops instead of .assign()
    double defaultVelocity = angularDisplacementPerImpulse / settings.maximumTimeBetweenImpulses;

    for (int i = 0; i < FLANK_ARRAY_SIZE; i++) {
        dirtyDataPoints[i] = settings.maximumTimeBetweenImpulses;
        cleanDataPoints[i] = settings.maximumTimeBetweenImpulses;
        angularVelocity[i] = defaultVelocity;
        angularAcceleration[i] = 0.1;
    }

    numberOfSequentialCorrections = 0;
    maxNumberOfSequentialCorrections = (settings.smoothing >= 2 ? settings.smoothing : 2);
}

void MovingFlankDetector::pushValue(double dataPoint) {
    // 1. Shift Data
    // Use the Kconfig limit to prevent overflow
    int len = settings.flankLength;
    if (len >= FLANK_ARRAY_SIZE) len = FLANK_ARRAY_SIZE - 1;

    for (int i = len; i > 0; i--) {
        dirtyDataPoints[i] = dirtyDataPoints[i - 1];
        cleanDataPoints[i] = cleanDataPoints[i - 1];
        angularVelocity[i] = angularVelocity[i - 1];
        angularAcceleration[i] = angularAcceleration[i - 1];
    }
    dirtyDataPoints[0] = dataPoint;

    // 2. Noise Filter: Bounds Check
    if (dataPoint < settings.minimumTimeBetweenImpulses || dataPoint > settings.maximumTimeBetweenImpulses) {
        LOG_DBG("Noise Filter: Out of bounds %f", dataPoint);
        dataPoint = cleanDataPoints[1];
    }

    // 3. Noise Filter: Change Limiter
    movingAverage.pushValue(dataPoint);
    double currentAverage = movingAverage.getAverage();
    double previousClean = cleanDataPoints[1];

    bool isPlausible = false;
    if (currentAverage > (settings.maximumDownwardChange * previousClean) &&
        currentAverage < (settings.maximumUpwardChange * previousClean)) {
        isPlausible = true;
    }

    if (isPlausible) {
        numberOfSequentialCorrections = 0;
    } else {
        if (numberOfSequentialCorrections <= maxNumberOfSequentialCorrections) {
            movingAverage.replaceLastPushedValue(previousClean);
            numberOfSequentialCorrections++;
        }
    }

    // 4. Update Derived Metrics
    cleanDataPoints[0] = movingAverage.getAverage();

    if (cleanDataPoints[0] > 0) {
        angularVelocity[0] = angularDisplacementPerImpulse / cleanDataPoints[0];
        angularAcceleration[0] = (angularVelocity[0] - angularVelocity[1]) / cleanDataPoints[0];
    } else {
        angularVelocity[0] = 0;
        angularAcceleration[0] = 0;
    }
}

bool MovingFlankDetector::isFlywheelPowered() {
    int numberOfErrors = 0;
    int len = settings.flankLength;
    if (len >= FLANK_ARRAY_SIZE) len = FLANK_ARRAY_SIZE - 1;

    for (int i = len; i > 1; i--) {
        if (cleanDataPoints[i] < cleanDataPoints[i - 1]) {
            numberOfErrors++;
        }
    }
    if (cleanDataPoints[1] <= cleanDataPoints[0]) {
        numberOfErrors++;
    }
    return (numberOfErrors <= settings.numberOfErrorsAllowed);
}

bool MovingFlankDetector::isFlywheelUnpowered() {
    int numberOfErrors = 0;
    int len = settings.flankLength;
    if (len >= FLANK_ARRAY_SIZE) len = FLANK_ARRAY_SIZE - 1;

    for (int i = len; i > 0; i--) {
        if (cleanDataPoints[i] >= cleanDataPoints[i - 1]) {
            numberOfErrors++;
        }
    }
    return (numberOfErrors <= settings.numberOfErrorsAllowed);
}

double MovingFlankDetector::timeToBeginOfFlank() {
    double total = 0.0;
    int len = settings.flankLength;
    if (len >= FLANK_ARRAY_SIZE) len = FLANK_ARRAY_SIZE - 1;

    for(int i = 0; i <= len; i++) {
        total += dirtyDataPoints[i];
    }
    return total;
}

double MovingFlankDetector::noImpulsesToBeginFlank() {
    return (double)settings.flankLength;
}

double MovingFlankDetector::impulseLengthAtBeginFlank() {
    return cleanDataPoints[settings.flankLength];
}

double MovingFlankDetector::accelerationAtBeginOfFlank() {
    return angularAcceleration[settings.flankLength - 1];
}

modules/physics_engine/RowingEngine.h
#pragma once

#include <zephyr/kernel.h>
#include "RowingSettings.h"
#include "MovingFlankDetector.h"
#include "RowingData.h"
#include "MovingAverager.h"

// Interface for Observer
class RowingEngineObserver {
public:
    virtual void onStrokeStart(const RowingData& data) {}
    virtual void onStrokeEnd(const RowingData& data) {}
    virtual void onMetricsUpdate(const RowingData& data) {}
};

class RowingEngine {
private:
    RowingSettings settings;
    MovingFlankDetector flankDetector;
    MovingAverager dragFactorAverager;

    // Data Protection
    mutable k_mutex dataLock; // Mutable allows locking even in 'const' functions
    RowingData currentData;

    RowingEngineObserver* observer = nullptr;

    // Internal State
    double angularDisplacementPerImpulse;
    double drivePhaseStartTime = 0;
    double drivePhaseStartAngularDisplacement = 0;
    double recoveryPhaseStartTime = 0;
    double recoveryPhaseStartAngularDisplacement = 0;
    double previousAngularVelocity = 0;

    // Helpers
    double calculateLinearVelocity(double driveAngle, double recoveryAngle, double cycleTime);
    double calculateCyclePower(double driveAngle, double recoveryAngle, double cycleTime);
    double calculateTorque(double dt, double currentVel);

    void startDrivePhase(double dt);
    void updateDrivePhase(double dt);
    void startRecoveryPhase(double dt);
    void updateRecoveryPhase(double dt);

public:
    explicit RowingEngine(RowingSettings settings);

    void handleRotationImpulse(double dt);
    void setObserver(RowingEngineObserver* obs);
    void reset();

    // Thread-Safe Accessor
    RowingData getData();
};

modules/physics_engine/RowingEngine.cpp
#include "RowingEngine.h"
#include <cmath>
#include <zephyr/logging/log.h>

LOG_MODULE_REGISTER(RowingEngine, LOG_LEVEL_INF);

RowingEngine::RowingEngine(RowingSettings rs)
    : settings(rs),
      flankDetector(rs),
      dragFactorAverager(rs.dampingConstantSmoothing, rs.dragFactor) {

    k_mutex_init(&dataLock);
    angularDisplacementPerImpulse = (2.0 * 3.14159265359) / settings.numOfImpulsesPerRevolution;
    reset();
}

RowingData RowingEngine::getData() {
    k_mutex_lock(&dataLock, K_FOREVER);
    RowingData copy = currentData;
    k_mutex_unlock(&dataLock);
    return copy;
}

void RowingEngine::setObserver(RowingEngineObserver* obs) {
    this->observer = obs;
}

void RowingEngine::reset() {
    k_mutex_lock(&dataLock, K_FOREVER);
    currentData = RowingData();
    currentData.dragFactor = settings.dragFactor;
    currentData.state = RowingState::RECOVERY;
    k_mutex_unlock(&dataLock);

    dragFactorAverager.reset(settings.dragFactor);

    double plausibleDisplacement = 8.0 / std::pow(settings.dragFactor / settings.magicConstant, 1.0/3.0);
    recoveryPhaseStartTime = -2.0 * settings.minimumRecoveryTime;
    recoveryPhaseStartAngularDisplacement = -1.0 * (2.0/3.0) * plausibleDisplacement / angularDisplacementPerImpulse;
    previousAngularVelocity = 0;
}

void RowingEngine::handleRotationImpulse(double dt) {
    if (dt > settings.maximumImpulseTimeBeforePause) {
        // Simple log, no logic change needed for pause yet
        return;
    }

    k_mutex_lock(&dataLock, K_FOREVER);
    currentData.totalTime += dt;
    RowingState currentState = currentData.state;
    k_mutex_unlock(&dataLock);

    flankDetector.pushValue(dt);

    if (currentState == RowingState::DRIVE) {
        if (flankDetector.isFlywheelUnpowered()) {
            double driveLen = (currentData.totalTime - flankDetector.timeToBeginOfFlank()) - drivePhaseStartTime;
            if (driveLen >= settings.minimumDriveTime) {
                startRecoveryPhase(dt);
            } else {
                updateDrivePhase(dt);
            }
        } else {
            updateDrivePhase(dt);
        }
    } else {
        if (flankDetector.isFlywheelPowered()) {
            double recLen = (currentData.totalTime - flankDetector.timeToBeginOfFlank()) - recoveryPhaseStartTime;
            if (recLen >= settings.minimumRecoveryTime) {
                startDrivePhase(dt);
            } else {
                updateRecoveryPhase(dt);
            }
        } else {
            updateRecoveryPhase(dt);
        }
    }
}

void RowingEngine::startDrivePhase(double dt) {
    double endTime = currentData.totalTime - flankDetector.timeToBeginOfFlank();
    double recoveryLen = endTime - recoveryPhaseStartTime;
    double driveLen = currentData.driveDuration;

    k_mutex_lock(&dataLock, K_FOREVER);
    if (recoveryLen >= settings.minimumRecoveryTime && driveLen >= settings.minimumDriveTime) {
        double cycleTime = driveLen + recoveryLen;
        currentData.lastStrokeTime = cycleTime;
        currentData.spm = 60.0 / cycleTime;
    }
    currentData.state = RowingState::DRIVE;
    currentData.strokeCount++;
    RowingData snapshot = currentData;
    k_mutex_unlock(&dataLock);

    drivePhaseStartTime = endTime;
    if (observer) observer->onStrokeStart(snapshot);
}

void RowingEngine::updateDrivePhase(double dt) {
    double currentVel = angularDisplacementPerImpulse / dt;
    double torque = calculateTorque(dt, currentVel);

    k_mutex_lock(&dataLock, K_FOREVER);
    currentData.instantaneousTorque = torque;
    RowingData snapshot = currentData;
    k_mutex_unlock(&dataLock);

    if (observer) observer->onMetricsUpdate(snapshot);
}

void RowingEngine::startRecoveryPhase(double dt) {
    double endTime = currentData.totalTime - flankDetector.timeToBeginOfFlank();

    k_mutex_lock(&dataLock, K_FOREVER);
    currentData.driveDuration = endTime - drivePhaseStartTime;
    currentData.state = RowingState::RECOVERY;

    double driveImpulses = (currentData.driveDuration / dt);
    double driveAngle = driveImpulses * angularDisplacementPerImpulse;
    double recoveryAngle = (currentData.recoveryDuration / dt) * angularDisplacementPerImpulse;
    double cycleTime = currentData.driveDuration + currentData.recoveryDuration;

    currentData.speed = calculateLinearVelocity(driveAngle, recoveryAngle, cycleTime);
    currentData.power = calculateCyclePower(driveAngle, recoveryAngle, cycleTime);
    currentData.distance += (currentData.speed * cycleTime);

    RowingData snapshot = currentData;
    k_mutex_unlock(&dataLock);

    recoveryPhaseStartTime = endTime;
    if (observer) observer->onStrokeEnd(snapshot);
}

void RowingEngine::updateRecoveryPhase(double dt) {
    double currentVel = angularDisplacementPerImpulse / dt;
    double torque = calculateTorque(dt, currentVel);

    k_mutex_lock(&dataLock, K_FOREVER);
    currentData.instantaneousTorque = torque;
    RowingData snapshot = currentData;
    k_mutex_unlock(&dataLock);

    if (observer) observer->onMetricsUpdate(snapshot);
}

double RowingEngine::calculateTorque(double dt, double currentVel) {
    double alpha = (currentVel - previousAngularVelocity) / dt;
    double torque = settings.flywheelInertia * alpha + settings.dragFactor * std::pow(currentVel, 2);
    previousAngularVelocity = currentVel;
    return torque;
}

double RowingEngine::calculateLinearVelocity(double driveAngle, double recoveryAngle, double cycleTime) {
    if (cycleTime <= 0) return 0;
    double totalAngle = driveAngle + recoveryAngle;
    double factor = std::pow(settings.dragFactor / settings.magicConstant, 1.0/3.0);
    return factor * (totalAngle / cycleTime);
}

double RowingEngine::calculateCyclePower(double driveAngle, double recoveryAngle, double cycleTime) {
    if (cycleTime <= 0) return 0;
    double totalAngle = driveAngle + recoveryAngle;
    double avgAngularVel = totalAngle / cycleTime;
    return settings.dragFactor * std::pow(avgAngularVel, 3.0);
}

modules/rowing_core/RowingData.h
#pragma once

enum class RowingState {
    IDLE,
    DRIVE,
    RECOVERY
};

struct RowingData {
    // Current State
    RowingState state = RowingState::IDLE;

    // Time
    double totalTime = 0.0;          // Seconds since start
    double lastStrokeTime = 0.0;     // Duration of the previous cycle
    double driveDuration = 0.0;      // Duration of current/last drive
    double recoveryDuration = 0.0;   // Duration of current/last recovery

    // Physics
    double distance = 0.0;           // Total Meters
    double speed = 0.0;              // m/s (Average for the stroke)
    // Add instntaneousPace and averagePace then remove speed (Pace is seconds per 500m) 1/(speed*500)
    double power = 0.0;              // Watts (Average for the stroke)
    double dragFactor = 0.0;         // Drag Coefficient

    // Live Data (High Frequency)
    double instantaneousTorque = 0.0;// For Force Curve
    double spm = 0.0;                // Strokes Per Minute
    int strokeCount = 0;
};

modules/rowing_core/RowingSettings.h
#pragma once

#include <zephyr/kernel.h>
#include <cstdint>

/**
 * @brief Configuration struct for the Open Rowing Monitor Physics Engine.
 * * This struct maps Zephyr Kconfig values (defined in module/RowingSettings/Kconfig)
 * to usable C++ types (doubles, bools) for the physics engine.
 * * It handles the conversion from "scaled integers" (used in Kconfig) to
 * actual floating point units (seconds, kg*m^2, etc).
 */
struct RowingSettings {
    // =========================================================
    // 1. Physics Constants
    // =========================================================

    // Number of magnets on the flywheel (default: 1)
    double numOfImpulsesPerRevolution = (double)CONFIG_ORM_IMPULSES_PER_REV;

    // Flywheel Inertia in kg*m^2.
    // Kconfig uses x10000 scaling (e.g., 600 -> 0.06 kg*m^2)
    double flywheelInertia = (double)CONFIG_ORM_FLYWHEEL_INERTIA_X10000 / 10000.0;

    // Magic Constant for distance calculation.
    // Kconfig uses x10000 scaling (e.g. 28000 -> 2.8)
    // Note: We default to 2.8 (Concept2 standard) if not defined.
    #ifdef CONFIG_ORM_MAGIC_CONSTANT_X10000
    double magicConstant = (double)CONFIG_ORM_MAGIC_CONSTANT_X10000 / 10000.0;
    #else
    double magicConstant = 2.8;
    #endif

    // =========================================================
    // 2. Timing & Validation Limits (Seconds)
    // =========================================================

    // Shortest valid time between magnets. Filters switch bounce/noise.
    double minimumTimeBetweenImpulses = (double)CONFIG_ORM_MIN_TIME_BETWEEN_IMPULSE_X10000 / 10000.0;

    // Longest valid time between magnets. Slower than this = Pause/Stop.
    double maximumTimeBetweenImpulses = (double)CONFIG_ORM_MAX_TIME_BETWEEN_IMPULSE_X10000 / 10000.0;

    // Minimum duration required for a valid Drive Phase.
    double minimumDriveTime = (double)CONFIG_ORM_MIN_DRIVE_TIME_X10000 / 10000.0;

    // Minimum duration required for a valid Recovery Phase.
    double minimumRecoveryTime = (double)CONFIG_ORM_MIN_RECOVERY_TIME_X10000 / 10000.0;

    // Max time allowed for a single impulse before assuming the user paused the workout.
    double maximumImpulseTimeBeforePause = (double)CONFIG_ORM_MAX_IMPULSE_TIME_BEFORE_PAUSE_X10000 / 10000.0;

    // =========================================================
    // 3. Flank Detection & Noise Filters
    // =========================================================

    // Size of the moving average buffer (e.g., 4 samples).
    int smoothing = CONFIG_ORM_SMOOTHING;

    // Number of samples to confirm a phase change (Drive <-> Recovery).
    int flankLength = CONFIG_ORM_FLANK_LENGTH;

    // Error tolerance for noise in direction detection.
    int numberOfErrorsAllowed = CONFIG_ORM_NUM_OF_ERRORS_ALLOWED;

    // Max allowed acceleration % per impulse (e.g. 0.25 = 25%).
    double maximumDownwardChange = (double)CONFIG_ORM_MAXIMUM_DOWNWARD_CHANGE_X10000 / 10000.0;

    // Max allowed deceleration % per impulse (e.g. 1.75 = 175%).
    double maximumUpwardChange = (double)CONFIG_ORM_MAXIMUM_UPWARD_CHANGE_X10000 / 10000.0;

    // Natural deceleration of flywheel (if using pure physics detection).
    double naturalDeceleration = (double)CONFIG_ORM_NATURAL_DECELARATION_X10000 / 10000.0;

    // =========================================================
    // 4. Drag Factor Logic
    // =========================================================

    // Base Drag Factor.
    // Note: JS engine divides by 1,000,000.
    // If Kconfig is 1500, this becomes 0.0015.
    double dragFactor = (double)CONFIG_ORM_DRAG_FACTOR / 1000000.0;

    // Check if Auto-Adjust feature is enabled in Kconfig
    bool autoAdjustDragFactor = IS_ENABLED(CONFIG_ORM_AUTO_ADJUST_DRAG_FACTOR);

    // Conditional members: These only exist or have valid values if Auto-Adjust is ON.
    // We use pre-processor directives to provide safe defaults if the config is missing.
    #ifdef CONFIG_ORM_AUTO_ADJUST_DRAG_FACTOR
        int dampingConstantSmoothing = CONFIG_ORM_DAMPING_CONSTANT_SMOOTING;
        // Max change allowed in Drag Factor (e.g. 0.1 = 10%)
        double dampingConstantMaxChange = (double)CONFIG_ORM_DAMPING_CONSTANT_MAX_CHANGE_X10000 / 10000.0;
    #else
        // Dummy defaults to prevent compilation errors if referenced
        int dampingConstantSmoothing = 1;
        double dampingConstantMaxChange = 0.0;
    #endif
};
